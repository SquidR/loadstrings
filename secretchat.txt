-- Secret Chat (centered + draggable + mobile friendly)
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

-- CONFIG
local SEED = 2031
local ALPHABET = "abcdefghijklmnopqrstuvwxyz"

-- Build deterministic shuffled alphabet
local rng = Random.new(SEED)
local letters = {}
for i = 1, #ALPHABET do
    letters[i] = ALPHABET:sub(i, i)
end
for i = #letters, 2, -1 do
    local j = rng:NextInteger(1, i)
    letters[i], letters[j] = letters[j], letters[i]
end

-- Build encode / decode maps (preserve case)
local encodeMap, decodeMap = {}, {}
for i = 1, #ALPHABET do
    local p = ALPHABET:sub(i, i)
    local c = letters[i]
    encodeMap[p] = c
    encodeMap[p:upper()] = c:upper()
    decodeMap[c] = p
    decodeMap[c:upper()] = p:upper()
end

local function encode(text)
    return text:gsub(".", function(ch)
        return encodeMap[ch] or ch
    end)
end

local function decode(text)
    return text:gsub(".", function(ch)
        return decodeMap[ch] or ch
    end)
end

-- CREATE GUI (CoreGui so executors can show it)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SecretChatGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = game:GetService("CoreGui")

-- Main frame: centered with AnchorPoint 0.5,0.5
local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.Position = UDim2.new(0.5, 0, 0.5, 0) -- center of screen
frame.Size = UDim2.new(0.42, 0, 0.6, 0) -- default for desktop
frame.BackgroundColor3 = Color3.fromRGB(23, 23, 23)
frame.BorderSizePixel = 0
frame.Parent = screenGui
frame.ClipsDescendants = true
frame.Active = true

-- Titlebar + close
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 34)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
titleBar.BorderSizePixel = 0
titleBar.Parent = frame

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -40, 1, 0)
title.Position = UDim2.new(0, 6, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Secret Chat"
title.TextSize = 18
title.Font = Enum.Font.SourceSansBold
title.TextColor3 = Color3.new(1, 1, 1)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 34, 1, 0)
closeBtn.Position = UDim2.new(1, -36, 0, 0)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.SourceSansBold
closeBtn.TextSize = 18
closeBtn.BackgroundTransparency = 1
closeBtn.TextColor3 = Color3.fromRGB(255, 100, 100)
closeBtn.Parent = titleBar

closeBtn.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Scroll area for decoded messages
local scroll = Instance.new("ScrollingFrame")
scroll.Name = "MessageScroll"
scroll.Position = UDim2.new(0, 8, 0, 42)
scroll.Size = UDim2.new(1, -16, 1, -122)
scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
scroll.ScrollBarThickness = 8
scroll.BackgroundTransparency = 1
scroll.BorderSizePixel = 0
scroll.Parent = frame

local uiLayout = Instance.new("UIListLayout")
uiLayout.SortOrder = Enum.SortOrder.LayoutOrder
uiLayout.Padding = UDim.new(0, 6)
uiLayout.Parent = scroll

-- Input box + send button
local inputBox = Instance.new("TextBox")
inputBox.Name = "InputBox"
inputBox.Size = UDim2.new(1, -92, 0, 36)
inputBox.Position = UDim2.new(0, 8, 1, -62)
inputBox.PlaceholderText = "Type secret message..."
inputBox.Text = ""
inputBox.TextColor3 = Color3.new(1,1,1)
inputBox.BackgroundColor3 = Color3.fromRGB(36,36,36)
inputBox.BorderSizePixel = 0
inputBox.ClipsDescendants = true
inputBox.ClearTextOnFocus = false
inputBox.Font = Enum.Font.SourceSans
inputBox.TextSize = 18
inputBox.Parent = frame

local sendBtn = Instance.new("TextButton")
sendBtn.Size = UDim2.new(0, 72, 0, 36)
sendBtn.Position = UDim2.new(1, -82, 1, -62)
sendBtn.Text = "Send"
sendBtn.Font = Enum.Font.SourceSansBold
sendBtn.TextSize = 18
sendBtn.BackgroundColor3 = Color3.fromRGB(50,50,50)
sendBtn.BorderSizePixel = 0
sendBtn.Parent = frame

-- helper to add a decoded message line
local function addMessage(sender, decodedText)
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, -8, 0, 20)
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 16
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Text = ("%s: %s"):format(sender, decodedText)
    lbl.Parent = scroll

    -- update canvas and auto-scroll (give layout a frame to compute)
    RunService.Heartbeat:Wait()
    scroll.CanvasSize = UDim2.new(0, 0, 0, uiLayout.AbsoluteContentSize.Y + 8)
    scroll.CanvasPosition = Vector2.new(0, math.max(0, uiLayout.AbsoluteContentSize.Y - scroll.AbsoluteWindowSize.Y))
end

-- Listen for all incoming chat messages and decode them
local function getChannel()
    local chan = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
    if not chan then
        TextChatService.TextChannels.ChildAdded:Wait()
        chan = TextChatService.TextChannels:WaitForChild("RBXGeneral")
    end
    return chan
end

local channel = getChannel()
channel.MessageReceived:Connect(function(message)
    local sender = message.TextSource and message.TextSource.Name or "System"
    local decodedText = decode(message.Text)
    addMessage(sender, decodedText)
end)

-- Send: encode then post to real chat (TextChatService)
local function sendEncoded(text)
    local encoded = encode(text)
    local ok, err = pcall(function()
        channel:SendAsync(encoded)
    end)
    if not ok then
        warn("Failed to send encoded message:", err)
    end
    -- Usually MessageReceived will catch your own message and display decoded version.
    -- If network/filters prevent that, uncomment fallback:
    -- addMessage(LocalPlayer.Name, text)
end

sendBtn.MouseButton1Click:Connect(function()
    if inputBox.Text ~= "" then
        sendEncoded(inputBox.Text)
        inputBox.Text = ""
    end
end)

inputBox.FocusLost:Connect(function(enterPressed)
    if enterPressed and inputBox.Text ~= "" then
        sendEncoded(inputBox.Text)
        inputBox.Text = ""
    end
end)

-- ===== Make frame draggable (works with mouse & touch) =====
-- We'll use pixel math with AbsolutePosition/AbsoluteSize, but keep AnchorPoint centered.
local dragging = false
local dragInput = nil
local dragStart = nil -- Vector2: input.Position at start
local startTopLeft = nil -- Vector2: top-left pixel of frame at start

local function onInputBegan(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        -- only start drag if started on titleBar (so other interactions are unaffected)
        local absPos = input.Position
        local inTitleBar = (absPos.Y >= titleBar.AbsolutePosition.Y and absPos.Y <= titleBar.AbsolutePosition.Y + titleBar.AbsoluteSize.Y)
            and (absPos.X >= titleBar.AbsolutePosition.X and absPos.X <= titleBar.AbsolutePosition.X + titleBar.AbsoluteSize.X)
        if not inTitleBar then return end

        dragging = true
        dragInput = input
        dragStart = input.Position
        startTopLeft = Vector2.new(frame.AbsolutePosition.X, frame.AbsolutePosition.Y)
        -- capture the input changed event for this input
    end
end

local function onInputChanged(input)
    if not dragging or input ~= dragInput then return end
    local delta = input.Position - dragStart
    local newTopLeft = startTopLeft + delta

    -- Keep the frame fully onscreen: clamp to screen bounds
    local screenX = math.clamp(newTopLeft.X, 0, math.max(0, workspace.CurrentCamera.ViewportSize.X - frame.AbsoluteSize.X))
    local screenY = math.clamp(newTopLeft.Y, 0, math.max(0, workspace.CurrentCamera.ViewportSize.Y - frame.AbsoluteSize.Y))

    -- Position expects center because AnchorPoint = (0.5,0.5)
    local newCenterX = screenX + frame.AbsoluteSize.X * 0.5
    local newCenterY = screenY + frame.AbsoluteSize.Y * 0.5

    frame.Position = UDim2.new(0, newCenterX, 0, newCenterY)
end

local function onInputEnded(input)
    if input == dragInput then
        dragging = false
        dragInput = nil
    end
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputChanged:Connect(onInputChanged)
UserInputService.InputEnded:Connect(onInputEnded)

-- ===== Mobile adjustments =====
local function adjustForMobile()
    if UserInputService.TouchEnabled then
        -- Larger, full-width-ish for phones
        frame.Size = UDim2.new(0.92, 0, 0.78, 0)
        frame.Position = UDim2.new(0.5, 0, 0.5, 0)
        title.TextSize = 20
        inputBox.TextSize = 20
        uiLayout.Padding = UDim.new(0, 8)
    else
        -- desktop defaults
        frame.Size = UDim2.new(0.42, 0, 0.6, 0)
    end
end

adjustForMobile()
UserInputService:GetPropertyChangedSignal("TouchEnabled"):Connect(adjustForMobile)

-- END
